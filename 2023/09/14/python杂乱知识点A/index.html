<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="hhgw">





<title>Python杂乱知识点A | hhgw&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
            <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">hhgw&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">hhgw&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python杂乱知识点A</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">hhgw</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2023-09-14&nbsp;&nbsp;17:55:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/python/">python</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Python杂乱知识点A"><a href="#Python杂乱知识点A" class="headerlink" title="Python杂乱知识点A"></a>Python杂乱知识点A</h1><h2 id="from-future-import-annotations"><a href="#from-future-import-annotations" class="headerlink" title="from __future__ import annotations"></a><code>from __future__ import annotations</code></h2><p>在 Python 中，<code>from __future__ import annotations</code>语句更改了函数签名中类型注解的默认行为。此功能是在 Python 3.7 中引入的，它显着影响了类型提示的处理方式。</p>
<p>默认情况下，在 Python 3.7 及更早版本中，当您在函数签名中使用类型注释时，注释本身会立即求值。这可能会导致循环依赖问题，尤其是在处理在类型注释中引用自身的类时。</p>
<p><code>from __future__ import annotations</code>语句改变了这种行为。当您在代码开头包含此语句时，Python 将延迟类型注释的计算，直到解析整个模块之后。这意味着您可以使用模块后面定义的类型，即使它们是自引用的。</p>
<p>下面是一个例子来说明差异：</p>
<p>没有 <code>from __future__ import annotations</code>（Python 3.7 及更早版本）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(bar: List[foo]):</span><br><span class="line">    pass  # This will raise a NameError in Python 3.7 and earlier</span><br></pre></td></tr></table></figure>

<p>使用 <code>from __future__ import annotations</code>（Python 3.7 及更高版本）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import annotations</span><br><span class="line"></span><br><span class="line">def foo(bar: List[foo]):</span><br><span class="line">    pass  # No NameError here, since annotations are delayed</span><br></pre></td></tr></table></figure>

<p>从 Python 3.10 开始，默认启用  <code>from __future__ import annotations</code>的行为，这意味着您不需要显式包含此语句。在 Python 3.10 及更高版本中，注释被视为来自未来的导入注释始终有效。进行此更改是为了提高类型提示的可用性，特别是在处理循环引用时。</p>
<blockquote>
<p>Here’s what optional <code>from __future__ import annotations</code> changes in python 3.7+:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>) -&gt; A: <span class="comment"># NameError: name &#x27;A&#x27; is not defined</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>but this works</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>) -&gt; A:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>See <a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/3.7.html#pep-563-postponed-evaluation-of-annotations">this</a> chapter in python 3.7 what’s new about postponed annotations:</p>
<blockquote>
<p>Since this change breaks compatibility, the new behavior needs to be enabled on a per-module basis in Python 3.7 using a <code>__future__</code> import:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import annotations</span><br></pre></td></tr></table></figure>

<p>It will become the default in Python <del>3.10</del>*.</p>
</blockquote>
<p>* it was announced to be default in 3.10 (when python3.7 was released), but it was now moved to a later release</p>
</blockquote>
<h2 id="内存管理，栈内存和堆内存"><a href="#内存管理，栈内存和堆内存" class="headerlink" title="内存管理，栈内存和堆内存"></a>内存管理，栈内存和堆内存</h2><p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-program-work-principle">https://www.gairuo.com/p/python-program-work-principle</a></p>
<h2 id="Python-星号表达式（Starred-Expression）"><a href="#Python-星号表达式（Starred-Expression）" class="headerlink" title="Python 星号表达式（Starred Expression）"></a>Python 星号表达式（Starred Expression）</h2><p>Python 星号表达式（Starred Expression）的形式有 <code>*</code>、<code>*args</code>、<code>**</code> 和 <code>**kwargs</code>，用于将可迭代的数据或者参数序列按一定的数据形式解析出来。</p>
<hr>
<p>关于星号表达式的理解，可以简单地认为：</p>
<ul>
<li>它能将可迭代的数据（iterable，由多全元素组成、能拆分的数据类型）拆开一系列独立元素；</li>
<li>拆开时要指定整体的数据类型（就是将这一个个元素最终形成什么数据结构）；</li>
<li>一个星号是拆开序列（类似列表），两个星号是拆开字典（mapping），即 <code>*iterable</code> 和<code>**dictionary</code>；</li>
<li><code>*args</code> 和 <code>**kwargs</code> 星号后为什么有变量名呢？因为在作为函数的参数时需要有变量名去使用，这两个变量名是约定俗成，你用别的也可以（不建议用别的）。</li>
</ul>
<p>马上进入例子：</p>
<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="string">&#x27;gairuo&#x27;</span> <span class="comment"># 一个普通字符串，可以拆开（迭代）</span></span><br><span class="line">[*h] <span class="comment"># [&#x27;g&#x27;, &#x27;a&#x27;, &#x27;i&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;o&#x27;] 列表</span></span><br><span class="line">&#123;*h&#125; <span class="comment"># &#123;&#x27;a&#x27;, &#x27;g&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;u&#x27;&#125; 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将两个元组合并为一个元组</span></span><br><span class="line">x,y = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(*x,*y) <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, 1, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并字典</span></span><br><span class="line">x = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">y = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment"># 拆成字典（还是自己）</span></span><br><span class="line">&#123;**x&#125;</span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line">&#123;**x, **y&#125; <span class="comment"># 合并</span></span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4&#125;</span></span><br><span class="line">&#123;**y, **x&#125; <span class="comment"># 换位置合并（其实字典一般不用在意位置）</span></span><br><span class="line"><span class="comment"># &#123;&#x27;b&#x27;: 2, &#x27;c&#x27;: 4, &#x27;a&#x27;: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>具体功能：</p>
<h3 id="1解包-unpack"><a href="#1解包-unpack" class="headerlink" title="1解包 unpack"></a>1解包 unpack</h3><p>星号表达式一个最最要的作用是解包（unpack），解包就是把一个整体数据按每个元素拆开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*[<span class="number">1</span>], *[<span class="number">2</span>,<span class="number">3</span>], *(<span class="number">4</span>, <span class="number">5</span>), <span class="number">6</span>)</span><br><span class="line"><span class="comment"># 1 2 3 4 5 6</span></span><br><span class="line"><span class="built_in">dict</span>(**&#123;<span class="string">&#x27;x1&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;x2&#x27;</span>: <span class="number">1</span>&#125;, y=<span class="number">2</span>, **&#123;<span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment"># &#123;&#x27;x1&#x27;: 0, &#x27;x2&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>上例中，第一个语句将两个列表和一个元组拆开，最终返回的是单个元素；第二行代码将字典拆开，拆开后它与其他字典的定义组成了一个新的字典，完成了字典合并的工作。</p>
<p>我们发现，解包操作有以下特点：</p>
<ul>
<li>被解包的数据必须是可迭代的，可以是字符串、元组、列表、字典、array、Series 等等；</li>
<li>解包后要有一定的数据结构去承接（接纳），如果单纯用星号是错误的（如 <code>*a</code>，应该是 <code>[*a]</code>）；</li>
<li><code>*iterable</code> 和 <code>**dictionary</code> 对应解包的是无 key 的和 有 key （mapping）的；</li>
</ul>
<p>以下是一个利用 Pandas 的综合例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>(**pd.Series([*<span class="string">&#x27;abcd&#x27;</span>], index=[*<span class="string">&#x27;1234&#x27;</span>]))</span><br><span class="line"><span class="comment"># &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;, &#x27;4&#x27;: &#x27;d&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>构建 Series 时的索引和值都可以将字符串进行解包成列表，由于 Series 是一个有key （mapping）的数据结构，我们可以将其用两个星号解包成字典。</p>
<h3 id="2定义变量"><a href="#2定义变量" class="headerlink" title="2定义变量"></a>2定义变量</h3><p>星号表达式在我们定义变量时也可以让我们的操作非常简便，利用它在给变量赋值时，可以将变量成为一个容器（catch-all）来容纳未分配有明确定义的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, *b, c = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">a <span class="comment"># 0</span></span><br><span class="line">c <span class="comment"># 4</span></span><br><span class="line">b <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>以上，b 使用了星号表达式，就容纳了中间所有的元素形成了一个列表。这就实现了类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first, rest = seq[<span class="number">0</span>], seq[<span class="number">1</span>:]</span><br><span class="line">first, *rest = seq <span class="comment"># 效果同上</span></span><br></pre></td></tr></table></figure>

<p>减少了代码量，更加便捷。对于更复杂的解包模式，新语法看起来更干净，不再需要笨拙的索引处理。</p>
<p>此外，如果右边的值不是列表，而是 iterable，则必须将其转换为列表才能进行切片。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>定义函数时，经常会使用 <code>*args</code> 和 <code>**kwargs</code> 来声明元组变量（位置变量）和字典变量（关键字变量）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">args = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">range</span>(*args) <span class="comment"># 这样就将两个位置变量传入</span></span><br><span class="line"><span class="comment"># range(1, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d, sep = <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 1&amp;2&amp;3&amp;4</span></span><br><span class="line">f(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment">#  1&amp;2&amp;3&amp;4</span></span><br></pre></td></tr></table></figure>



<h2 id="Python-单下划线变量"><a href="#Python-单下划线变量" class="headerlink" title="Python 单下划线变量"></a>Python 单下划线变量</h2><p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-underscore-variable">https://www.gairuo.com/p/python-underscore-variable</a></p>
<h2 id="Python-迭代"><a href="#Python-迭代" class="headerlink" title="Python 迭代"></a>Python 迭代</h2><p>Python 对于容器类型数据支持逐个进行迭代处理，迭代会对所有元素按照一个逻辑进行计算操作。因此在 Python 所有数据范围内就存在类型是否是可迭代的话题。为了高效完成迭代操作，Python 专门设计了迭代器类型，这类数据专门用来迭代操作。最后，为了高效快捷创建一个迭代器类型，Python 又有一个生成器类型成生成一个可迭代对象。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>迭代（iteration）是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果可能会被用来作为下一次迭代的初始值。</p>
<p>比如将购买的散装鸡蛋放心冰箱时，我们打开冰箱门后，一个一个地将其从篮子里拿出摆放到冰箱，每次 捡拾-&gt;搁放 就是一次迭代，这个过程不断重复，走到篮子里的鸡蛋全部放心冰箱。</p>
<p>在计算机科学中，迭代是程序中对一组指令（或一定步骤）的重复，是按照某种顺序逐个访问列表中的每一项。</p>
<p>在编程中，还有一个类似的概念叫 递归（Recursion），我们可以放在一起进行理解。</p>
<p>在函数内部，调用函数自身的编程技巧称为递归（ recursion）。递归函数结构清晰，很直观的理解计算过程，但也有严重缺点：相对于普通循环而言，递归运行效率较低，经过很多冗余的计算，递归会消耗大量的调用堆栈。</p>
<p>迭代和递归都是一个事情多次重复下去，解决问题，不过思路不一样。</p>
<p>例子：</p>
<ul>
<li>递归：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！…</li>
<li>迭代：愚公移山，子子孙孙无穷无尽，干同一件事情。</li>
</ul>
<h3 id="迭代操作"><a href="#迭代操作" class="headerlink" title="迭代操作"></a>迭代操作</h3><p>在 Python 中，我们可以用多种方式来进行迭代操作。最常见的是使用 for 循环来遍历这个 list 或 tuple 等数据。</p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-for">for 语句</a> 是最简便的迭代方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果要让元素在迭代时有下标，可以使用内置函数 <a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-enumerate">enumerate()</a>，它会将索引与每个元素形成一个元组对。</p>
<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>Python 的内置函数 <a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-next">next()</a> 从迭代器返回下一项。如果给定了默认值，并且迭代器已耗尽，则返回它，而不是引发 StopIteration 错误。我们在使用 next() 前一定要确保操作的对象是一个 迭代器，如果不是可以<strong>用内置函数 <a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-iter">iter()</a> 转为一个迭代器</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="built_in">iter</span>(lst)</span><br><span class="line"><span class="comment"># &lt;list_iterator at 0x7f8482698250&gt;</span></span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">next</span>(it) <span class="comment"># &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">next</span>(it) <span class="comment"># &#x27;b&#x27;</span></span><br><span class="line"><span class="built_in">next</span>(it) <span class="comment"># &#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment"># StopIteration:</span></span><br></pre></td></tr></table></figure>

<h4 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h4><p>列表推导式、字典推导式，都可以完成类似迭代的操作，我们可以将数据转为一个列表和字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> foo]</span><br><span class="line"><span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line">&#123;i:<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> foo&#125;</span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 0, &#x27;b&#x27;: 0, &#x27;c&#x27;: 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然，上边的过程可以附带操作或者调用函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">print</span>(<span class="string">f&#x27;哎呀！迭代<span class="subst">&#123;i&#125;</span>了&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> foo]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">哎呀！迭代a了</span></span><br><span class="line"><span class="string">哎呀！迭代b了</span></span><br><span class="line"><span class="string">哎呀！迭代c了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[None, None, None]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>不过不建议这么操作。</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>可以使用 while 对可迭代对象转成的迭代器进行 next() 下一个项的操作，直到迭代完所有项，、抛出 StopIteration 错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">iterable = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">iter_obj = <span class="built_in">iter</span>(iterable)</span><br><span class="line"></span><br><span class="line"><span class="comment"># infinite loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># get the next item</span></span><br><span class="line">        element = <span class="built_in">next</span>(iter_obj)</span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># if StopIteration is raised, break from loop</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h2><p>更多内容：</p>
<p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-type-annotations">https://www.gairuo.com/p/python-type-annotations</a></p>
<p>简单说，Python 类型注解功能可以让我们的代码更加易读，从而达到编写更加健壮的代码目标。类型注解又叫类型暗示，将函数、变量声明为一种特定类型。当然，它并不是严格的类型绑定，所以这个机制并不能阻止调用者传入不应该传入的参数。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于 Python 是一个动态语言，定义和使用变量时不需要申明变量的数据类型即可使用，但这样也会带来一定的问题，如阅读代码时不知道数据是什么类型，调用时不小心会传入错误的数据类型。因此，Python 的类型注解功能就显得比较重要了。</p>
<p>一个字符和数字类型是无法相加的，否则会报以下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">a + b</span><br><span class="line"><span class="comment"># TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p>调用者在使用函数时如果没有完善的文档，不知道要传入的数据类型分别是什么，同时文档也很难表达复杂的数据类型。有了类型注解可以让 IDE 知道了数据类型后，更加准确地进行自动补全。有了类型注解可以提供给第三方工具，做代码分析，发现隐形bug。函数注解的信息，保存在 <code>__annotations__</code> 属性中可以来调用。</p>
<p>在 Python 3.5 中，Python PEP 484 引入了类型注解（type hints），在 Python 3.6 中，PEP 526 又进一步引入了变量注解（Variable Annotations）。</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>以下是一个使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量</span></span><br><span class="line">x: <span class="built_in">int</span> = <span class="number">2</span></span><br><span class="line">x: <span class="built_in">int</span> | <span class="built_in">float</span> = <span class="number">2</span> <span class="comment"># 表示 or Python 3.10 开始支持</span></span><br><span class="line">x + <span class="number">1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个除法函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看类型注解信息</span></span><br><span class="line">div.__annotations__</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">int</span>, <span class="string">&#x27;b&#x27;</span>: <span class="built_in">int</span>, <span class="string">&#x27;return&#x27;</span>: <span class="built_in">float</span>&#125;</span><br></pre></td></tr></table></figure>

<p>语法注意的点：</p>
<ul>
<li>变量类型：在变量名后加一个冒号，冒号后写变量的数据类型，如 int、dict 等</li>
<li>函数返回类型：方法参数中如变量类型，在参数括号后加一个箭头，箭头后返回值的类型</li>
<li>格式要求（PEP 8，非强制）：变量名和冒号无空格，冒号和后边类型间加一个空格，箭头左右均有一个空格</li>
</ul>
<h3 id="提示性"><a href="#提示性" class="headerlink" title="提示性"></a>提示性</h3><p>但值得注意的是，这种类型和变量注解实际上只是一种类型提示，对运行实际上是没有影响的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看返回类型</span></span><br><span class="line"><span class="built_in">type</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># int</span></span><br></pre></td></tr></table></figure>

<p>比如上例，调用 add 方法的时候，我们注解返回一个字符串，但它返回的仍然是 int，也不会报错，也不会对参数进行类型转换。</p>
<p>不过有了类型注解，一些 IDE 是可以识别出来并提示的，比如 PyCharm 就可以识别出来在调用某个方法的时候参数类型不一致，会提示 WARNING。如类似以下字典嵌套列表类型的提示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Expected type &#x27;Mapping[str, str]&#x27;,</span></span><br><span class="line"><span class="string">got &#x27;Dict[str, Union[List[str], List[Union[bool, str]]]]&#x27; instead</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>asyncio</p>
<p><a target="_blank" rel="noopener" href="https://www.gairuo.com/p/python-asynchronous">https://www.gairuo.com/p/python-asynchronous</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_async_job</span>(<span class="params">fut</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&#x27;Hello future&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    future = loop.create_future()</span><br><span class="line">    loop.create_task(do_async_job(future))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等到 future 有结果</span></span><br><span class="line">    <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(future.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># Hello future</span></span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>hhgw</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2023 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>There is no fate but what <strong>we</strong> make.</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/python/"># python</a>
                    
                        <a href="/tags/annotations/"># annotations</a>
                    
                        <a href="/tags/%E6%A0%88%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/"># 栈和堆内存</a>
                    
                        <a href="/tags/%E6%98%9F%E5%8F%B7/"># 星号*</a>
                    
                        <a href="/tags/%E8%BF%AD%E4%BB%A3iter/"># 迭代iter</a>
                    
                        <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A/"># 类型注释</a>
                    
                        <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Basyncio/"># 异步编程asyncio</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/09/14/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%BB%BA%E7%AB%8B/">python建立虚拟环境(mac)</a>
            
            
            <a class="next" rel="next" href="/2023/09/05/Transformer%E5%A4%87%E5%BF%98/">Transformer备忘</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© hhgw | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>